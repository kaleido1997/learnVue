<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>126 component other</title>
</head>
<body>
    <div id="app">
        <h1>$nextTick</h1>——用于获取与html元素相关的变量，因其只可在vue实例被渲染后才可被调用<br/>
        <div id="div" v-if="showDiv">Some content</div>
        <button @click="getText">Get content in div</button>
        <!--        v-if：异步更新队列-->
        <!--        上述代码运行后在控制台会抛出一个错误：Cannot read property 'innerHTML' of null，就是获取不到div元素-->
        <!--        （这里如果将v-if改成v-show则不会报错；在点了一次按钮后，之后再点也不会报错，因为此时v-if为true，div已经渲染出来了）-->
        <!--        原因是Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。-->
        <!--        在缓冲时会去除重复数据，从而避免不必要的计算和DOM操作。然后在下一个事件循环tick中，刷新队列井执行己去重的工作。-->
        <!--        所以如果用一个for循环来动态改变数据100次，其实它只会应用最后一次改变。如果没有这种机制，DOM就要重绘100次，这显然是一个很大的开销。-->

        <!--        $nextTick内包含的代码则会在DOM更新后执行-->
<!--        另可见：https://segmentfault.com/a/1190000012861862-->
<!--        在created和mounted阶段，如果需要操作渲染后的视图，也要使用nextTick方法：-->
<!--        mounted: function() {-->
<!--            this.$nextTick(function () {-->
<!--                // Code that would only run after the entire view has been rendered-->
<!--            })-->
<!--        }-->
        <button @click="getTextNew">Get content in div without errors</button>
        <hr>

        <h1>X-Templates</h1>
<!--        Vue提供了另一种定义模板的方式，在<script>标签里使用text/x-template类型，并且指定一个id，将这个id赋给template。-->
        <comp-xtemp></comp-xtemp>
        <script type="text/x-template" id="tempid">     <!-- 这样就可以在script里写html代码 -->
            <div>Content in this component</div>
        </script>
        <hr>
    </div>

    <script src="https://unpkg.com/vue/dist/vue.min.js"></script>
    <script>
        Vue.component('comp-xtemp', {
            template: '#tempid'
        });

        var app = new Vue ({
            el: '#app',
            data: {
                showDiv: false
            },
            methods: {
                getText() {
                    this.showDiv = true;
                    var text = document.getElementById('div').innerHTML;
                    console.log(text);
                },
                getTextNew() {
                    this.showDiv = true;
                    this.$nextTick(function () {
                        var text = document.getElementById('div').innerHTML;
                        console.log(text);
                    })
                }
            }
        });
    </script>

    <div id="mount-div">
        <h1>手动挂载Vue实例</h1>
        <!--        之前所创建的实例都是通过new Vue()的形式创建出来的。在一些特殊情况下，需要动态地去创建Vue实例。-->
        <!--        Vue提供了Vue.extend和$mount两个方法来手动挂载一个实例。-->
        <!--        Vue.extend是基础Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象。-->
        <!--        如果Vue实例在实例化时没有收到el选项，它就处于“未挂载”状态，没有关联的DOM元素。-->
        <!--        然后可以使用$mount()手动地挂载一个未挂载的实例。这个方法返回实例自身，因而可以链式调用其他实例方法。-->
    </div>
    <script>
        var mycomp = Vue.extend({
            template: '<div>Hello: {{ name }}</div>',
            data: function () {
                return {
                    name: 'abc'
                }
            }
        });
        new mycomp().$mount('#mount-div');
        // 或：
        // new mycomp({
        //     el: '#mount-div'
        // });
        // 或：
        // var comp = new mycomp().$mount();
        // document.getElementById('mount-div').appendChild(comp.$el)
        // 运行后，id为mount-div的div元素（即h1中的内容）会被替换为组件mycomp的template的内容
    </script>
</body>
</html>
